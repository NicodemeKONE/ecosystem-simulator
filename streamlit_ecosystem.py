# streamlit_ecosystem.py - Version Streamlit corrig√©e
# Int√©gration compl√®te pour portfolio GitHub/Streamlit

import streamlit as st
import pandas as pd
import numpy as np
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
import time
import random
import json
from datetime import datetime

# Configuration de la page
st.set_page_config(
    page_title="üåç Simulateur d'√âcosyst√®me",
    page_icon="ü¶Å",
    layout="wide",
    initial_sidebar_state="expanded"
)

# CSS personnalis√© pour un meilleur design
st.markdown("""
<style>
    .main-header {
        font-size: 3rem;
        font-weight: bold;
        text-align: center;
        color: #2E7D32;
        margin-bottom: 2rem;
    }
    .ecosystem-stats {
        background: linear-gradient(90deg, #e3f2fd, #f3e5f5);
        padding: 1rem;
        border-radius: 10px;
        margin: 1rem 0;
    }
    .animal-card {
        background: white;
        padding: 1rem;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        margin: 0.5rem 0;
    }
    .stButton > button {
        width: 100%;
        background: linear-gradient(90deg, #4CAF50, #45a049);
        color: white;
        border: none;
        border-radius: 5px;
        padding: 0.5rem;
        font-weight: bold;
    }
    .status-running {
        color: #4CAF50;
        font-weight: bold;
    }
    .status-paused {
        color: #FF9800;
        font-weight: bold;
    }
</style>
""", unsafe_allow_html=True)

# Classes simplifi√©es pour Streamlit
class StreamlitAnimal:
    def __init__(self, species, x, y, life, max_life, age=0):
        self.species = species
        self.x = x
        self.y = y
        self.life = life
        self.max_life = max_life
        self.age = age
        self.direction_x = random.choice([-1, 0, 1])
        self.direction_y = random.choice([-1, 0, 1])
        
    def move(self, grid_width, grid_height):
        """D√©placement al√©atoire"""
        new_x = max(0, min(grid_width - 1, self.x + self.direction_x))
        new_y = max(0, min(grid_height - 1, self.y + self.direction_y))
        
        # Changer de direction parfois
        if random.random() < 0.3:
            self.direction_x = random.choice([-1, 0, 1])
            self.direction_y = random.choice([-1, 0, 1])
            
        self.x, self.y = new_x, new_y
        
    def lose_energy(self, amount=1):
        """Perte d'√©nergie"""
        self.life = max(0, self.life - amount)
        
    def gain_energy(self, amount=5):
        """Gain d'√©nergie"""
        self.life = min(self.max_life, self.life + amount)
        
    def is_alive(self):
        return self.life > 0
        
    def age_one_year(self):
        self.age += 1

class EcosystemSimulator:
    def __init__(self, width=20, height=20):
        self.width = width
        self.height = height
        self.animals = []
        self.resources = []
        self.turn = 0
        self.stats_history = []
        
        # Configuration
        self.animal_configs = {
            'Mouse': {'emoji': 'üê≠', 'color': '#8D6E63', 'max_life': 15, 'energy_cost': 1},
            'Cow': {'emoji': 'üêÑ', 'color': '#6D4C41', 'max_life': 40, 'energy_cost': 1},
            'Lion': {'emoji': 'ü¶Å', 'color': '#FF8F00', 'max_life': 50, 'energy_cost': 2},
            'Dragon': {'emoji': 'üê≤', 'color': '#D32F2F', 'max_life': 100, 'energy_cost': 1}
        }
        
    def add_animal(self, species, count):
        """Ajoute des animaux √† l'√©cosyst√®me"""
        config = self.animal_configs[species]
        for _ in range(count):
            x = random.randint(0, self.width - 1)
            y = random.randint(0, self.height - 1)
            life = random.randint(config['max_life'] // 2, config['max_life'])
            animal = StreamlitAnimal(species, x, y, life, config['max_life'])
            self.animals.append(animal)
            
    def add_resources(self, herb_count, water_count):
        """Ajoute des ressources"""
        self.resources = []
        
        # Herbes
        for _ in range(herb_count):
            x = random.randint(0, self.width - 1)
            y = random.randint(0, self.height - 1)
            self.resources.append({'type': 'Herb', 'x': x, 'y': y, 'emoji': 'üåø', 'value': 5})
            
        # Eau
        for _ in range(water_count):
            x = random.randint(0, self.width - 1)
            y = random.randint(0, self.height - 1)
            self.resources.append({'type': 'Water', 'x': x, 'y': y, 'emoji': 'üíß', 'value': 10})
            
    def simulate_turn(self):
        """Simule un tour"""
        self.turn += 1
        
        # D√©placer les animaux
        for animal in self.animals:
            if animal.is_alive():
                animal.move(self.width, self.height)
                animal.lose_energy(self.animal_configs[animal.species]['energy_cost'])
                
                # Consommer ressources
                for resource in self.resources[:]:
                    if animal.x == resource['x'] and animal.y == resource['y']:
                        animal.gain_energy(resource['value'])
                        self.resources.remove(resource)
                        break
        
        # Vieillissement (tous les 10 tours)
        if self.turn % 10 == 0:
            for animal in self.animals:
                animal.age_one_year()
                # Mort de vieillesse
                if animal.age > 20 and random.random() < 0.1:
                    animal.life = 0
        
        # Reproduction simple
        if self.turn % 15 == 0:
            self.simple_reproduction()
            
        # Pr√©dation simple
        self.simple_predation()
        
        # Nettoyer les morts
        self.animals = [a for a in self.animals if a.is_alive()]
        
        # Respawn des ressources
        if self.turn % 5 == 0:
            self.respawn_resources()
            
        # Sauvegarder les stats
        self.save_stats()
        
    def simple_predation(self):
        """Pr√©dation simplifi√©e"""
        predation_rules = {
            'Dragon': ['Lion', 'Cow', 'Mouse'],
            'Lion': ['Cow', 'Mouse']
        }
        
        for predator in self.animals:
            if not predator.is_alive():
                continue
                
            if predator.species in predation_rules:
                for prey in self.animals:
                    if (prey.species in predation_rules[predator.species] and 
                        prey.is_alive() and
                        abs(predator.x - prey.x) <= 1 and 
                        abs(predator.y - prey.y) <= 1):
                        
                        # Chasse r√©ussie
                        if random.random() < 0.3:  # 30% de chance
                            prey.life = 0
                            predator.gain_energy(20)
                            break
                            
    def simple_reproduction(self):
        """Reproduction simplifi√©e"""
        species_groups = {}
        
        # Grouper par esp√®ce
        for animal in self.animals:
            if animal.is_alive() and animal.life > animal.max_life * 0.7:
                if animal.species not in species_groups:
                    species_groups[animal.species] = []
                species_groups[animal.species].append(animal)
        
        # Reproduction pour chaque esp√®ce
        for species, animals in species_groups.items():
            if len(animals) >= 2:
                parent1, parent2 = random.sample(animals, 2)
                
                # Cr√©er un b√©b√©
                if random.random() < 0.2:  # 20% de chance
                    config = self.animal_configs[species]
                    baby = StreamlitAnimal(
                        species, 
                        parent1.x, 
                        parent1.y, 
                        config['max_life'] // 2,
                        config['max_life']
                    )
                    self.animals.append(baby)
                    
                    # Co√ªt √©nerg√©tique pour les parents
                    parent1.lose_energy(15)
                    parent2.lose_energy(15)
                    
    def respawn_resources(self):
        """Fait r√©appara√Ætre des ressources"""
        current_herbs = len([r for r in self.resources if r['type'] == 'Herb'])
        current_water = len([r for r in self.resources if r['type'] == 'Water'])
        
        # Maintenir un nombre minimum
        min_herbs = 15
        min_water = 8
        
        if current_herbs < min_herbs:
            for _ in range(min_herbs - current_herbs):
                x = random.randint(0, self.width - 1)
                y = random.randint(0, self.height - 1)
                self.resources.append({'type': 'Herb', 'x': x, 'y': y, 'emoji': 'üåø', 'value': 5})
                
        if current_water < min_water:
            for _ in range(min_water - current_water):
                x = random.randint(0, self.width - 1)
                y = random.randint(0, self.height - 1)
                self.resources.append({'type': 'Water', 'x': x, 'y': y, 'emoji': 'üíß', 'value': 10})
                
    def save_stats(self):
        """Sauvegarde les statistiques"""
        stats = {'turn': self.turn}
        
        # Compter par esp√®ce
        for species in self.animal_configs.keys():
            count = len([a for a in self.animals if a.species == species and a.is_alive()])
            stats[species] = count
            
        # Ressources
        stats['Herbs'] = len([r for r in self.resources if r['type'] == 'Herb'])
        stats['Water'] = len([r for r in self.resources if r['type'] == 'Water'])
        stats['Total_Animals'] = len(self.animals)
        
        self.stats_history.append(stats)
        
    def get_grid_data(self):
        """Retourne les donn√©es pour affichage en grille"""
        grid = np.zeros((self.height, self.width), dtype=object)
        
        # Placer les ressources
        for resource in self.resources:
            if 0 <= resource['y'] < self.height and 0 <= resource['x'] < self.width:
                grid[resource['y']][resource['x']] = resource['emoji']
        
        # Placer les animaux (par-dessus les ressources)
        for animal in self.animals:
            if animal.is_alive() and 0 <= animal.y < self.height and 0 <= animal.x < self.width:
                emoji = self.animal_configs[animal.species]['emoji']
                grid[animal.y][animal.x] = emoji
                
        return grid

# Interface Streamlit
def main():
    # Titre principal
    st.markdown('<h1 class="main-header">üåç Simulateur d\'√âcosyst√®me Interactif</h1>', 
                unsafe_allow_html=True)
    
    # Initialisation de l'√©tat de session
    if 'ecosystem' not in st.session_state:
        st.session_state.ecosystem = None
        st.session_state.running = False
        st.session_state.auto_speed = 1.0
        st.session_state.last_update = time.time()
        
    # Sidebar - Configuration
    with st.sidebar:
        st.header("‚öôÔ∏è Configuration")
        
        # Taille de grille
        st.subheader("üåç Taille de la Plan√®te")
        grid_width = st.slider("Largeur", 10, 30, 20)
        grid_height = st.slider("Hauteur", 10, 30, 20)
        
        # Populations
        st.subheader("ü¶Å Populations d'Animaux")
        mice_count = st.number_input("üê≠ Souris", 0, 100, 20)
        cows_count = st.number_input("üêÑ Vaches", 0, 50, 8)
        lions_count = st.number_input("ü¶Å Lions", 0, 20, 4)
        dragons_count = st.number_input("üê≤ Dragons", 0, 10, 2)
        
        # Ressources
        st.subheader("üåø Ressources")
        herbs_count = st.number_input("üåø Herbes", 0, 100, 25)
        waters_count = st.number_input("üíß Points d'eau", 0, 50, 12)
        
        # Presets
        st.subheader("üé® Presets")
        preset = st.selectbox("Configurations pr√©d√©finies", [
            "Configuration Personnalis√©e",
            "√âquilibr√©",
            "Pr√©dateurs Dominants", 
            "Herbivores Paisibles",
            "Survie Extr√™me"
        ])
        
        if preset != "Configuration Personnalis√©e":
            if preset == "√âquilibr√©":
                mice_count, cows_count, lions_count, dragons_count = 20, 8, 4, 2
                herbs_count, waters_count = 25, 12
            elif preset == "Pr√©dateurs Dominants":
                mice_count, cows_count, lions_count, dragons_count = 30, 15, 10, 5
                herbs_count, waters_count = 40, 20
            elif preset == "Herbivores Paisibles":
                mice_count, cows_count, lions_count, dragons_count = 40, 20, 2, 1
                herbs_count, waters_count = 50, 25
            elif preset == "Survie Extr√™me":
                mice_count, cows_count, lions_count, dragons_count = 15, 6, 6, 3
                herbs_count, waters_count = 10, 5
        
        # Boutons de contr√¥le
        st.subheader("üéÆ Contr√¥les")
        
        if st.button("üöÄ Cr√©er √âcosyst√®me"):
            ecosystem = EcosystemSimulator(grid_width, grid_height)
            ecosystem.add_animal('Mouse', mice_count)
            ecosystem.add_animal('Cow', cows_count)
            ecosystem.add_animal('Lion', lions_count)
            ecosystem.add_animal('Dragon', dragons_count)
            ecosystem.add_resources(herbs_count, waters_count)
            st.session_state.ecosystem = ecosystem
            st.session_state.running = False
            st.session_state.last_update = time.time()
            st.success("üéâ √âcosyst√®me cr√©√©!")
            st.rerun()
            
        if st.session_state.ecosystem:
            col1, col2 = st.columns(2)
            
            with col1:
                if st.button("‚ñ∂Ô∏è Play" if not st.session_state.running else "‚è∏Ô∏è Pause"):
                    st.session_state.running = not st.session_state.running
                    st.session_state.last_update = time.time()
                    st.rerun()
                    
            with col2:
                if st.button("‚è≠Ô∏è Tour Suivant"):
                    st.session_state.ecosystem.simulate_turn()
                    st.rerun()
            
            # Vitesse de simulation
            st.subheader("‚ö° Vitesse")
            speed = st.select_slider(
                "Vitesse de simulation",
                options=[0.5, 1.0, 2.0, 3.0],
                value=st.session_state.auto_speed,
                format_func=lambda x: f"{x}x"
            )
            if speed != st.session_state.auto_speed:
                st.session_state.auto_speed = speed
            
            # Status
            if st.session_state.running:
                st.markdown('<p class="status-running">üü¢ Simulation en cours...</p>', 
                           unsafe_allow_html=True)
            else:
                st.markdown('<p class="status-paused">üü° Simulation en pause</p>', 
                           unsafe_allow_html=True)
        
        # Informations
        st.subheader("üìñ √Ä Propos")
        st.markdown("""
        **Simulateur d'√âcosyst√®me**
        
        üéØ **Objectif**: Observer l'√©volution d'un √©cosyst√®me virtuel
        
        üîß **Fonctionnalit√©s**:
        - Pr√©dation r√©aliste
        - Reproduction naturelle  
        - Gestion des ressources
        - Vieillissement
        - Statistiques temps r√©el
        
        üë®‚Äçüíª **D√©velopp√© par**: Nicod√®me KONE
        üîó **Mail**: nicoetude@gmail.com
        """)
    
    # Gestion de l'auto-refresh
    if st.session_state.ecosystem and st.session_state.running:
        current_time = time.time()
        time_since_last_update = current_time - st.session_state.last_update
        expected_delay = 1.0 / st.session_state.auto_speed
        
        if time_since_last_update >= expected_delay:
            st.session_state.ecosystem.simulate_turn()
            st.session_state.last_update = current_time
            time.sleep(0.1)  # Petite pause pour √©viter la surcharge
            st.rerun()
    
    # Zone principale
    if st.session_state.ecosystem:
        ecosystem = st.session_state.ecosystem
        
        # Statistiques en temps r√©el
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            total_animals = len(ecosystem.animals)
            st.metric("ü¶Å Total Animaux", total_animals)
            
        with col2:
            total_resources = len(ecosystem.resources)
            st.metric("üåø Total Ressources", total_resources)
            
        with col3:
            st.metric("üîÑ Tour Actuel", ecosystem.turn)
            
        with col4:
            density = ((total_animals + total_resources) * 100) // (ecosystem.width * ecosystem.height)
            st.metric("üìä Densit√©", f"{density}%")
        
        # Grille de l'√©cosyst√®me
        st.subheader("üåç Plan√®te en Temps R√©el")
        
        grid_data = ecosystem.get_grid_data()
        
        # Cr√©er la visualisation avec Plotly
        fig = go.Figure()
        
        # Ajouter les cellules
        for y in range(ecosystem.height):
            for x in range(ecosystem.width):
                cell_content = grid_data[y][x]
                if cell_content and cell_content != 0:
                    # D√©terminer la couleur selon le type
                    color = '#8FBC8F'  # Couleur par d√©faut
                    if cell_content in ['üåø']:
                        color = '#32CD32'
                    elif cell_content in ['üíß']:
                        color = '#1E90FF'
                    elif cell_content in ['üê≠']:
                        color = '#8D6E63'
                    elif cell_content in ['üêÑ']:
                        color = '#6D4C41'
                    elif cell_content in ['ü¶Å']:
                        color = '#FF8F00'
                    elif cell_content in ['üê≤']:
                        color = '#D32F2F'
                    
                    fig.add_trace(go.Scatter(
                        x=[x], y=[ecosystem.height - 1 - y],  # Inverser Y pour affichage correct
                        mode='markers+text',
                        text=[cell_content],
                        textfont=dict(size=20),
                        marker=dict(size=30, color=color, opacity=0.7),
                        showlegend=False,
                        hovertemplate=f'{cell_content}<br>Position: ({x}, {y})<extra></extra>'
                    ))
        
        # Configuration du graphique
        fig.update_layout(
            title="üåç √âcosyst√®me Vivant",
            xaxis=dict(range=[-0.5, ecosystem.width - 0.5], showgrid=True, gridcolor='lightgray'),
            yaxis=dict(range=[-0.5, ecosystem.height - 0.5], showgrid=True, gridcolor='lightgray'),
            width=800,
            height=600,
            plot_bgcolor='rgba(240,248,255,0.8)'
        )
        
        st.plotly_chart(fig, use_container_width=True)
        
        # D√©tails des populations
        col1, col2 = st.columns(2)
        
        with col1:
            st.subheader("ü¶Å Populations Actuelles")
            for species in ecosystem.animal_configs:
                count = len([a for a in ecosystem.animals if a.species == species])
                emoji = ecosystem.animal_configs[species]['emoji']
                st.write(f"{emoji} **{species}**: {count} individus")
                
                if count > 0:
                    # Statistiques de sant√©
                    animals_of_species = [a for a in ecosystem.animals if a.species == species]
                    avg_life = sum(a.life for a in animals_of_species) / len(animals_of_species)
                    avg_age = sum(a.age for a in animals_of_species) / len(animals_of_species)
                    st.write(f"   ‚ù§Ô∏è Vie moyenne: {avg_life:.1f}")
                    st.write(f"   üë¥ √Çge moyen: {avg_age:.1f} ans")
        
        with col2:
            st.subheader("üåø Ressources Disponibles")
            herbs = len([r for r in ecosystem.resources if r['type'] == 'Herb'])
            water = len([r for r in ecosystem.resources if r['type'] == 'Water'])
            
            st.write(f"üåø **Herbes**: {herbs} unit√©s")
            st.write(f"üíß **Eau**: {water} unit√©s")
            st.write(f"üìä **Total**: {herbs + water} ressources")
        
        # Graphiques d'√©volution
        if len(ecosystem.stats_history) > 1:
            st.subheader("üìà √âvolution des Populations")
            
            # Pr√©parer les donn√©es pour le graphique
            df_stats = pd.DataFrame(ecosystem.stats_history)
            
            # Graphique des populations
            fig_pop = px.line(df_stats, x='turn', 
                             y=['Mouse', 'Cow', 'Lion', 'Dragon'],
                             title="√âvolution des Populations Animales",
                             labels={'value': 'Nombre d\'individus', 'turn': 'Tour'})
            
            fig_pop.update_layout(height=400)
            st.plotly_chart(fig_pop, use_container_width=True)
            
            # Graphique des ressources
            fig_res = px.line(df_stats, x='turn',
                             y=['Herbs', 'Water'],
                             title="√âvolution des Ressources",
                             labels={'value': 'Quantit√©', 'turn': 'Tour'})
            
            fig_res.update_layout(height=300)
            st.plotly_chart(fig_res, use_container_width=True)
            
        # Logs et √©v√©nements
        if ecosystem.turn > 0:
            st.subheader("üìú Journal de l'√âcosyst√®me")
            
            recent_stats = ecosystem.stats_history[-1] if ecosystem.stats_history else {}
            
            st.write(f"**Tour {ecosystem.turn}**:")
            st.write(f"- Population totale: {total_animals} animaux")
            st.write(f"- Ressources disponibles: {total_resources}")
            
            if ecosystem.turn % 10 == 0:
                st.write("- üéÇ Vieillissement des animaux")
            if ecosystem.turn % 15 == 0:
                st.write("- üë∂ Saison de reproduction")
            if ecosystem.turn % 5 == 0:
                st.write("- üå± Respawn des ressources")
                
        # Force le refresh si en cours d'ex√©cution
        if st.session_state.running:
            time.sleep(0.01)
            st.rerun()
                
    else:
        # √âcran d'accueil
        st.subheader("üåü Bienvenue dans le Simulateur d'√âcosyst√®me!")
        
        col1, col2, col3 = st.columns([1, 2, 1])
        
        with col2:
            st.markdown("""
            ### üéØ Cr√©ez et observez un √©cosyst√®me vivant !
            
            **Fonctionnalit√©s**:
            - ü¶Å **4 esp√®ces d'animaux** avec comportements uniques
            - üåø **Syst√®me de ressources** dynamique
            - ‚öîÔ∏è **Pr√©dation r√©aliste** entre esp√®ces
            - üë∂ **Reproduction naturelle** des populations
            - üìä **Statistiques temps r√©el** et graphiques d'√©volution
            - üé® **Presets configurables** pour diff√©rents sc√©narios
            
            **Instructions**:
            1. **Configurez votre √©cosyst√®me dans la sidebar (>>) en haut √† droite ‚¨ÖÔ∏è**
            2. Cliquez sur "üöÄ Cr√©er √âcosyst√®me"
            3. Utilisez "‚ñ∂Ô∏è Play" pour lancer la simulation
            4. Observez l'√©volution en temps r√©el !
            5. Les statistiques sont tout en bas.
            
            ---
            
            *D√©velopp√© avec ‚ù§Ô∏è en Python + Streamlit*
            """)
        
        # Exemple de mini-√©cosyst√®me statique
        st.subheader("üëÄ Aper√ßu de l'Interface")
        
        # Cr√©er un exemple statique
        example_data = {
            'Species': ['üê≠ Souris', 'üêÑ Vaches', 'ü¶Å Lions', 'üê≤ Dragons', 'üåø Herbes', 'üíß Eau'],
            'Count': [18, 6, 3, 2, 22, 10],
            'Status': ['Stable', 'En croissance', 'Chasse active', 'Dominant', 'Abondante', 'Suffisante']
        }
        
        df_example = pd.DataFrame(example_data)
        st.dataframe(df_example, use_container_width=True)


if __name__ == "__main__":
    main()